-- BAZA DANYCH PRZEDSTAWIAJĄCA ZOO

CREATE TABLE areny(
    id_areny INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazwa_areny VARCHAR(50) NOT NULL UNIQUE);

-- Tabela areny zawiera w sobie nazwy aren znajdujących się na terenie zoo.

CREATE TABLE mapa(
    id_miejsca INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazwa_miejsca VARCHAR(50) NOT NULL UNIQUE,
    id_areny INTEGER NOT NULL REFERENCES areny(id_areny) ON DELETE CASCADE ON UPDATE CASCADE);

-- Tabela mapa zawiera miejsca (np. restauracje, kino) z podziałem na areny. Każde miejsce musi przynależeć dokładnie do jednej areny, ale na jednej arenie może być wiele miejsc. Jeśli usuniemy jakąś arenę, to kaskadowo usuną się rownież wszystkie miejsca do niej należące z mapy.

CREATE TABLE rodzaje_pozywienia(
    pozywienie VARCHAR(50) PRIMARY KEY);

-- Tabela rodzaje_pozywienia jest tabelą enumeracyjną dla tabeli wybiegi.

CREATE TABLE wybiegi(
    id_wybiegu INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazwa_wybiegu VARCHAR(50) NOT NULL UNIQUE,
    id_areny INTEGER NOT NULL REFERENCES areny(id_areny) ON DELETE RESTRICT ON UPDATE CASCADE,
    pozywienie VARCHAR(50) NOT NULL REFERENCES rodzaje_pozywienia(pozywienie) ON DELETE RESTRICT ON UPDATE CASCADE);

-- Tabela wybiegi to lista wybiegow w zoo. Każdy wybieg musi przynależeć do dokładnie jednej areny, ale na jednej arenie może być wiele wybiegow. Nie możemy usunąć areny, jeśli znajdują się tam wybiegi. Każdemu wybiegowi przypisujemy dokładnie jeden rodzaj dostarczanego tam pożywienia, ale dane pożywienie może być takie samo na wielu wybiegach. Nie możemy usunąć rodzaju pożywienia, jeśli jest on przypisany jakiemuś wybiegowi.


CREATE TABLE zwierzeta(
    id_zwierzaka INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    imie VARCHAR(50),
    gatunek VARCHAR(50) NOT NULL,
    data_urodzenia DATE,
    id_wybiegu INTEGER NOT NULL REFERENCES wybiegi(id_wybiegu) ON DELETE RESTRICT ON UPDATE CASCADE);

-- Tabela zwierzęta to lista zwierząt znajdujących się w zoo. Każde zwierzę może mieć imię i datę urodzenia (ale nie musi). Każde zwierzę ma określony gatunek oraz wybieg, na ktorym się znajduje. Dane zwierzę musi być tylko na jednym wybiegu, ale na jednym wybiegu może być kilka rożnych zwierząt. Nie możemy usunąć wybiegu, jeśli są tam zwierzęta.


CREATE TABLE nazwy_specjalizacji(
    specjalizacja VARCHAR(50) PRIMARY KEY);

-- Tabela nazwy_specjalizacji to tabela enumeracyjna dla tabeli opiekunowie.


CREATE TABLE opiekunowie(
    id_opiekuna INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    imie VARCHAR(50) NOT NULL,
    nazwisko VARCHAR(50) NOT NULL,
    specjalizacja VARCHAR(50) REFERENCES nazwy_specjalizacji(specjalizacja) ON DELETE RESTRICT ON UPDATE CASCADE,
    data_zatrudnienia DATE NOT NULL);


-- Tabela opiekunowie to lista opiekunow zwierząt pracujących w zoo. Każdy opiekun musi mieć imię, nazwisko i datę zatrudnienia w zoo. Może mieć też określoną specjalizację z tabeli nazwy_specjalizacji. Nie możemy usunąć nazwy specjalizacji, jeśli jakiś opiekun ja ma.

CREATE TABLE zwierzeta_opiekunowie(
    id_zwierzaka INTEGER REFERENCES zwierzeta(id_zwierzaka) ON DELETE CASCADE ON UPDATE CASCADE,
    id_opiekuna INTEGER REFERENCES opiekunowie(id_opiekuna) ON DELETE RESTRICT ON UPDATE CASCADE,
    PRIMARY KEY(id_zwierzaka, id_opiekuna));

-- Tabela zwierzeta_opiekunowie to tabela zawierająca pary zwierzaka i jego opiekuna. To tak zwana relacja n:n, gdyż jedno zwierzę może mieć wielu opiekunow, a jeden opiekun może opiekować się wieloma zwierzętami. Jeśli usuniemy z bazy danych zwierzę, to znikają jego pary z owej tabeli. Natomiast nie możemy usunąć opiekuna, jeśli istnieje zwierzę, ktorym się on opiekuje.

CREATE TABLE pokazy(
    id_pokazu INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nazwa_pokazu VARCHAR(50) NOT NULL,
    data_pokazu DATE NOT NULL,
    godzina_pokazu TIME NOT NULL,
    id_wybiegu INTEGER NOT NULL REFERENCES wybiegi(id_wybiegu) ON DELETE RESTRICT ON UPDATE CASCADE);

-- Tabela pokazy to spis pokazow, ktore odbywają się w zoo. Każdy pokaz musi mieć określone nazwę, datę pokazu z godziną oraz wybieg, na ktorym się odbywa. Nie możemy usunąć wybiegu z bazy, jeśli odbywają się tam pokazy.


CREATE TABLE odwiedzajacy(
    id_odwiedzajacego INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    imie VARCHAR(50) NOT NULL,
    nazwisko VARCHAR(50) NOT NULL,
    e_mail VARCHAR(100) UNIQUE NOT NULL);

-- Tabela odwiedzający to lista osob kupujących bilety. Osoba ta musi podać imię, nazwisko i e-mail. Na jeden e-mail może być zarejestrowana tylko jedna osoba.

CREATE TABLE rodzaje_biletow(
    id_rodzaju INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    rodzaj VARCHAR(50) NOT NULL UNIQUE,
    cena DECIMAL(6,2) NOT NULL CHECK (cena > 0));

-- Tabela rodzaje_biletow to tabela, ktora ukazuje dostępne do zakupu rodzaje biletow z ich ceną podstawową.

CREATE TABLE kasa(
    id_biletu INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_rodzaju INTEGER NOT NULL REFERENCES rodzaje_biletow(id_rodzaju) ON DELETE RESTRICT ON UPDATE CASCADE,
    data_wejscia DATE DEFAULT CURRENT_DATE NOT NULL,
    czy_datek BOOLEAN DEFAULT(false) NOT NULL,
    id_odwiedzajacego INTEGER NOT NULL REFERENCES odwiedzajacy(id_odwiedzajacego) ON DELETE RESTRICT ON UPDATE CASCADE,
    cena_koncowa DECIMAL(6,2) NOT NULL);

-- Tabela kasa umożliwa zakup biletow. Potrzebne do tego są: wybrany rodzaj biletu, deklaracja odnośnie datku, założone konto w tabeli odwiedzający. Można nadpisać datę wejścia, jednak domyślnie jest ona datą aktualną. Można rownież nadpisać cenę końcową, jednak domyślnie jest ona uzupełniania wyzwalaczem poniżej. Nie można usunąć rodzaju biletu, jeśli są kupione bilety z tym rodzajem. Nie można rownież usunąć konta odwiedzającego, jeśli przypisany jest do niego jakiś bilet, aby mieć dostęp do archiwalnych biletow.


CREATE OR REPLACE FUNCTION cena_biletu() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cena_koncowa IS NULL) THEN
        IF (NEW.czy_datek) THEN
            NEW.cena_koncowa = (SELECT 1.1 * cena
                                    FROM rodzaje_biletow
                                    WHERE rodzaje_biletow.id_rodzaju = NEW.id_rodzaju);
        ELSE
            NEW.cena_koncowa = (SELECT cena
                                    FROM rodzaje_biletow
                                    WHERE rodzaje_biletow.id_rodzaju = NEW.id_rodzaju);
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';


CREATE TRIGGER cena_biletu_trigger BEFORE INSERT ON kasa
    FOR EACH ROW EXECUTE PROCEDURE cena_biletu();



CREATE TABLE opinie(
    id_opinii INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_odwiedzajacego INTEGER UNIQUE NOT NULL REFERENCES odwiedzajacy(id_odwiedzajacego) ON DELETE RESTRICT ON UPDATE CASCADE,
    ocena INTEGER NOT NULL CHECK(ocena >= 0 AND ocena <= 10));

-- Tabela opinie służy do wystawiania opinii o naszym zoo. Przed wstawieniem krotki do tabeli, sprawdzane jest wyzwalaczem poniżej, czy wystawiający ocenę ma na swoim koncie zakupiony bilet. Jeśli nie, nie może on wystawić opinii, gdyż byłaby ona bezpodstawna.

CREATE OR REPLACE FUNCTION sprawdz_czy_bilet() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.id_odwiedzajacego NOT IN (SELECT id_odwiedzajacego
                                        FROM kasa)) THEN
        RAISE EXCEPTION 'Aby wystawić opinię, należy mieć zakupiony bilet na koncie.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';


CREATE TRIGGER sprawdz_czy_bilet_trigger BEFORE INSERT ON opinie
    FOR EACH ROW EXECUTE PROCEDURE sprawdz_czy_bilet();



CREATE VIEW historia_zakupow AS
    SELECT e_mail, data_wejscia, cena_koncowa, rodzaj, count(*) as liczba_biletow
        FROM kasa
            JOIN odwiedzajacy USING(id_odwiedzajacego)
            JOIN rodzaje_biletow USING(id_rodzaju)
        GROUP BY (e_mail, data_wejscia, cena_koncowa, rodzaj)
        ORDER BY data_wejscia;


CREATE VIEW przewodnik AS
    SELECT nazwa_areny, nazwa_miejsca
        FROM areny
            JOIN mapa USING(id_areny)
    UNION
    SELECT nazwa_areny, nazwa_wybiegu
        FROM areny
            JOIN wybiegi USING(id_areny);


CREATE VIEW harmonogram AS
    SELECT DISTINCT nazwa_pokazu, data_pokazu, godzina_pokazu, nazwa_wybiegu, gatunek
        FROM pokazy
            JOIN wybiegi USING(id_wybiegu)
            JOIN zwierzeta USING(id_wybiegu);


CREATE VIEW gdzie_zwierze AS
    SELECT DISTINCT gatunek, nazwa_areny, nazwa_wybiegu
        FROM zwierzeta
            JOIN wybiegi USING(id_wybiegu)
            JOIN areny USING (id_areny);


CREATE VIEW srednia_opinii AS
	SELECT avg(ocena)
	FROM opinie;


-- przykladowe dane:

INSERT INTO rodzaje_biletow(rodzaj, cena) VALUES ('ulgowy', 40), ('normalny', 60),
('studencki', 20), ('dla emerytow', 10);
INSERT INTO odwiedzajacy (imie, nazwisko, e_mail) VALUES ('Dagmara', 'Olszak', 'd.olszak@wp.pl'),
('Anna', 'Wojtkiewicz', 'aniaw1238@gmail.com'), ('Sylwia', 'Patrijas', 'p.sylwia2003@wp.pl');
INSERT INTO odwiedzajacy (imie, nazwisko, e_mail) VALUES ('Tomasz', 'Zawierucha', 't.zawieruch@wp.pl');
INSERT INTO odwiedzajacy(imie, nazwisko, e_mail) VALUES ('Adam', 'Nowak', 'adam@wp.pl');
INSERT INTO odwiedzajacy(imie, nazwisko, e_mail) VALUES ('Tomek', 'Kowalski', 'skorupa@wp.pl');
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego) VALUES (2, TRUE, 1);
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego) VALUES (4, FALSE, 3);
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego) VALUES (2, FALSE, 4);
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego, cena_koncowa) VALUES (4, FALSE, 2, 0);
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego) VALUES (2, TRUE, 1);
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego) VALUES (1, TRUE, 6);
INSERT INTO kasa(id_rodzaju, czy_datek, id_odwiedzajacego) VALUES (2, TRUE, 6);
INSERT INTO opinie(id_odwiedzajacego, ocena) VALUES(1, 5);
INSERT INTO opinie(id_odwiedzajacego, ocena) VALUES (2, 9), (3, 6), (4, 10), (6, 5);
INSERT INTO nazwy_specjalizacji VALUES ('weterynarz'), ('zoolog'), ('zootechnik'), ('gady'), ('plazy'), ('ssaki'), ('ptaki'), ('zwierzeta_wodne');
INSERT INTO opiekunowie(imie, nazwisko, specjalizacja, data_zatrudnienia) VALUES ('Romek', 'Kapusta', 'ssaki', '2023-09-23'), ('Danuta', 'Elfowa', 'weterynarz', '2010-09-11'), ('Andrzej', 'Piast', 'gady', '2025-01-22'), ('Robert', 'Lew', 'ssaki', '2022-12-18');
INSERT INTO rodzaje_pozywienia(pozywienie) VALUES('mieso'),('ryby'), ('padlina'), ('siano'),('liscie'), ('trawa');
INSERT INTO areny(nazwa_areny) VALUES ('wschodnia'), ('zachodnia'), ('polnocna'),('poludniowa'), ('centralna');
INSERT INTO mapa(nazwa_miejsca,id_areny) VALUES('restauracja sloneczko', 5), ('bar mis',3), ('toaleta', 1), ('park linowy', 2), ('kawiarnia', 4), ('kino', 5);
INSERT INTO wybiegi(nazwa_wybiegu, id_areny, pozywienie) VALUES ('wybieg lwow', 1,'mieso'), ('basen delfinow',2,'ryby'),  ('wybieg zyraf i zebr',3,'liscie'), ('wybieg niedzwiedzi', 4,'ryby'),('wybieg sloni',5,'siano'),('wybieg fok',2,'ryby');
INSERT INTO wybiegi(nazwa_wybiegu, id_areny, pozywienie) VALUES ('wybieg goryli', 2, 'mieso'), ('wybieg hipopotamow', 1, 'liscie'), ('wybieg malp', 4, 'liscie');
INSERT INTO wybiegi(nazwa_wybiegu, id_areny, pozywienie) VALUES('wybieg wezy', 4,'mieso');
INSERT INTO zwierzeta(imie,gatunek,data_urodzenia,id_wybiegu) VALUES ('Simba','lew','2021-07-20',1),('Mufasa','lew','2010-05-30',1),('Ariel','delfin','2005-03-28',2),('Luna','zyrafa','2020-08-03',3),('Antos','zebra','2020-02-13',3),('Uszatek', 'niedzwiedz','2017-04-20',4), ('Dambo','slon','2007-11-05',5),('Kaya','foka','2015-09-24',6),('Ryder','pyton','2023-06-12',10);
INSERT INTO zwierzeta(imie,gatunek,data_urodzenia,id_wybiegu) VALUES ('Donio', 'goryl', '2019-10-10', 7), ('Hipcio', 'hipopotam', '2020-11-11', 8), ('Kasia', 'hipopotam', '2018-01-01', 8), ('Dora', 'malpa', '2024-09-22', 9);
INSERT INTO zwierzeta_opiekunowie(id_zwierzaka, id_opiekuna) VALUES (1,1),(2,1),(3,2),(4,4),(5,4),(6,1),(7,2),(8,2),(9,3);
INSERT INTO zwierzeta_opiekunowie(id_zwierzaka, id_opiekuna) VALUES (10, 1), (11, 2), (12, 2), (13, 1);
INSERT INTO pokazy(nazwa_pokazu, data_pokazu, godzina_pokazu,id_wybiegu) VALUES ('pokaz lwow', '2025-01-22','14:30:00',1),('pokaz delfinow','2025-02-03','19:00:00',2),('pokaz fok','2025-01-23','13:30:00',6);
INSERT INTO pokazy(nazwa_pokazu, data_pokazu, godzina_pokazu,id_wybiegu) VALUES ('pokaz hipopotamow', '2025-01-28', '19:00:00', 8), ('pokaz goryli', '2025-01-29', '19:00:00', 7), ('pokaz delfinow', '2025-01-30', '10:00:00', 2);




-- funkcje potrzebne do interfejsu:

CREATE OR REPLACE FUNCTION kup_bilet(email TEXT, w_rodzaj TEXT, datek INTEGER, data DATE) RETURNS NUMERIC AS $$
DECLARE
    id_odw INTEGER;
    id_rodz INTEGER;
    czy_dat BOOLEAN;
    _id_biletu INTEGER;
    cena NUMERIC(6,2);

BEGIN
    SELECT id_odwiedzajacego INTO id_odw
        FROM odwiedzajacy
            WHERE e_mail = email;

    SELECT id_rodzaju INTO id_rodz
        FROM rodzaje_biletow
            WHERE rodzaj = w_rodzaj;

     IF datek = 1 THEN
        czy_dat := TRUE;
    ELSE
        czy_dat := FALSE;
    END IF;

    INSERT INTO kasa(id_rodzaju, data_wejscia, czy_datek, id_odwiedzajacego)
        VALUES (id_rodz, data, czy_dat, id_odw)
        RETURNING id_biletu INTO _id_biletu;

    SELECT cena_koncowa INTO cena
        FROM kasa
            WHERE id_biletu = _id_biletu;

    RETURN cena;
END;
$$ LANGUAGE 'plpgsql';




CREATE OR REPLACE FUNCTION dodaj_konto(imie1 TEXT, nazwisko1 TEXT, mail1 TEXT) RETURNS TEXT AS $$

DECLARE
    wynik TEXT;

BEGIN

    wynik = 'Konto z tym e-mailem juz istnieje';

    IF mail1 NOT IN (SELECT e_mail FROM odwiedzajacy) THEN
        wynik = 'Konto zostalo utworzone';
        INSERT INTO odwiedzajacy(imie, nazwisko, e_mail)
            VALUES (imie1, nazwisko1, mail1);
    END IF;

    return wynik;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION wypisz_arene(gatunek1 TEXT) RETURNS TEXT AS $$

DECLARE

    wynik TEXT;

BEGIN

    SELECT DISTINCT nazwa_areny INTO wynik
                FROM zwierzeta
                    JOIN wybiegi USING(id_wybiegu)
                    JOIN areny USING (id_areny)
                WHERE gatunek = gatunek1;

    return wynik;
END;
$$ LANGUAGE 'plpgsql';



CREATE OR REPLACE FUNCTION dodaj_opinie(email3 TEXT, ocena3 INTEGER) RETURNS VOID AS $$
	DECLARE
		id_email INTEGER;
		stara_ocena INTEGER;

	BEGIN
		SELECT id_odwiedzajacego INTO id_email FROM odwiedzajacy WHERE e_mail = email3;
		SELECT ocena INTO stara_ocena FROM opinie WHERE id_odwiedzajacego = id_email;
		IF(FOUND) THEN
			UPDATE opinie SET ocena = ocena3 WHERE id_odwiedzajacego = id_email;
		ELSE
			INSERT INTO opinie(id_odwiedzajacego, ocena) VALUES (id_email, ocena3);
		END IF;
	END;
$$ LANGUAGE 'plpgsql';












